import sys
import cv2
import numpy as np
import socketio
import threading
import time
import queue
import os

from PyQt6.QtWidgets import (
    QApplication, QWidget, QLabel, QPushButton, QVBoxLayout, QHBoxLayout, 
    QMessageBox, QComboBox, QGroupBox, QGridLayout, QSpinBox
)
from PyQt6.QtCore import Qt, QTimer, pyqtSignal, QObject, QThread
from PyQt6.QtGui import QImage, QPixmap

SERVER_URL = "http://192.168.1.146:5000"
CHESSBOARD_SIZE = (15,8)
SQUARE_SIZE = 0.016  # in meters

sio = socketio.Client()

class FrameBridge(QObject):
    new_frame = pyqtSignal(np.ndarray)

bridge = FrameBridge()
frame_queue = queue.Queue(maxsize=2)

# All resolutions for UI dropdown and general reference
RESOLUTION_LIST = [
    ("768x432", (768, 432)),
    ("1024x576", (1024, 576)),
    ("1536x864", (1536, 864)), # Base 1
    ("1920x1080", (1920, 1080)),
    ("2304x1296", (2304, 1296)), # Base 2
    ("2560x1440", (2560, 1440)),
    ("2880x1620", (2880, 1620)),
    ("3456x1944", (3456, 1944)),
    ("4608x2592", (4608, 2592)), # Base 3
]

# Base resolutions to be calibrated directly
BASE_CALIBRATION_RESOLUTIONS = [
    (1536, 864),
    (2304, 1296),
    (4608, 2592),
]

# Mapping from base resolution to resolutions derived from it
# Derived resolutions will have their calibration files generated by scaling the base.
DERIVED_MAPPINGS = {
    (1536, 864): [(768, 432), (1024, 576)],
    (2304, 1296): [(1920, 1080), (2560, 1440)],
    (4608, 2592): [(2880, 1620), (3456, 1944)],
}

# Maps all resolution tuples to their target .npz filenames
# Ensures the "calibrations" subfolder is consistently used.
CALIBRATIONS_SUBDIR = "calibrations"
RESOLUTION_FILES = {
    res_tuple: os.path.join(CALIBRATIONS_SUBDIR, f"calibration_{res_tuple[0]}x{res_tuple[1]}.npz")
    for _, res_tuple in RESOLUTION_LIST
}


class CalibrationWorker(QObject):
    calibration_finished = pyqtSignal(bool, object, object, str) # success, mtx, dist, error_message

    def __init__(self, objpoints, imgpoints, img_shape):
        super().__init__()
        self.objpoints = objpoints
        self.imgpoints = imgpoints
        self.img_shape = img_shape

    def run(self):
        try:
            ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(
                self.objpoints, self.imgpoints, self.img_shape, None, None
            )
            if ret:
                self.calibration_finished.emit(True, mtx, dist, "")
            else:
                self.calibration_finished.emit(False, None, None, "cv2.calibrateCamera returned False.")
        except Exception as e:
            self.calibration_finished.emit(False, None, None, f"Exception during calibration: {e}")

class CalibrationApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Calibration Tool")
        self.setMinimumSize(1200, 700)

        # Main layout
        main_layout = QHBoxLayout()
        
        # Left side - Controls
        controls_layout = QVBoxLayout()
        
        # Resolution Control Group
        res_group = QGroupBox("Resolution Control")
        res_layout = QVBoxLayout()
        
        self.resolution_combo = QComboBox()
        for label, _ in RESOLUTION_LIST:
            self.resolution_combo.addItem(label)
        
        self.jpeg_quality_spinbox = QSpinBox()
        self.jpeg_quality_spinbox.setRange(1, 100)
        self.jpeg_quality_spinbox.setValue(70) 
        self.jpeg_quality_spinbox.setEnabled(False) # Disable JPEG quality control for now
        
        self.fps_spinbox = QSpinBox()
        self.fps_spinbox.setRange(1, 60) 
        self.fps_spinbox.setValue(1) # Default to 1 for calibration
        
        self.set_resolution_btn = QPushButton("Apply Stream Settings")
        self.set_resolution_btn.clicked.connect(self.apply_stream_settings)
        
        self.current_res_label = QLabel("Current: Unknown")
        
        self.start_stream_btn = QPushButton("Start Camera Stream")
        self.stop_stream_btn = QPushButton("Stop Camera Stream")
        self.start_stream_btn.clicked.connect(lambda: sio.emit("start_camera"))
        self.stop_stream_btn.clicked.connect(lambda: sio.emit("stop_camera"))
        
        res_layout.addWidget(QLabel("Select Resolution:"))
        res_layout.addWidget(self.resolution_combo)
        res_layout.addWidget(QLabel("JPEG Quality (1-100):"))
        res_layout.addWidget(self.jpeg_quality_spinbox)
        res_layout.addWidget(QLabel("Target FPS:"))
        res_layout.addWidget(self.fps_spinbox)
        res_layout.addWidget(self.set_resolution_btn)
        res_layout.addWidget(self.current_res_label)
        res_layout.addWidget(self.start_stream_btn)
        res_layout.addWidget(self.stop_stream_btn)
        res_group.setLayout(res_layout)
        
        # Calibration Control Group
        calib_group = QGroupBox("Calibration Controls")
        calib_layout = QVBoxLayout()
        
        self.capture_btn = QPushButton("Capture Frame")
        self.calibrate_btn = QPushButton("Calibrate")
        self.save_btn = QPushButton("Save Calibration")
        self.reset_btn = QPushButton("Reset/New Calibration")
        
        self.capture_btn.clicked.connect(self.capture_frame)
        self.calibrate_btn.clicked.connect(self.run_calibration)
        self.save_btn.clicked.connect(self.save_calibration)
        self.reset_btn.clicked.connect(self.reset_calibration)
        
        # Initially disable calibration buttons
        self.capture_btn.setEnabled(False)
        self.calibrate_btn.setEnabled(False)
        self.save_btn.setEnabled(False)
        
        calib_layout.addWidget(self.capture_btn)
        calib_layout.addWidget(self.calibrate_btn)
        calib_layout.addWidget(self.save_btn)
        calib_layout.addWidget(self.reset_btn)
        
        # New button to clear all calibrations
        self.clear_all_calib_btn = QPushButton("Clear All Saved Calibrations")
        self.clear_all_calib_btn.clicked.connect(self.confirm_clear_all_calibrations)
        calib_layout.addWidget(self.clear_all_calib_btn) # Add it to the layout
        
        calib_group.setLayout(calib_layout)
        
        # Status Group
        status_group = QGroupBox("Status & Progress")
        status_layout = QVBoxLayout()
        
        self.count_label = QLabel("Captured: 0")
        self.status_label = QLabel("Status: Waiting for stream...")
        self.info_label = QLabel(f"Chessboard: {CHESSBOARD_SIZE[0]}x{CHESSBOARD_SIZE[1]} | Square: {SQUARE_SIZE}m")
        self.progress_label = QLabel("")
        self.connection_status_label = QLabel("Socket.IO: Disconnected")
        
        status_layout.addWidget(self.count_label)
        status_layout.addWidget(self.status_label)
        status_layout.addWidget(self.info_label)
        status_layout.addWidget(self.progress_label)
        status_layout.addWidget(self.connection_status_label) # Add to status group
        status_group.setLayout(status_layout)
        
        # Add groups to controls
        controls_layout.addWidget(res_group)
        controls_layout.addWidget(calib_group)
        controls_layout.addWidget(status_group)
        controls_layout.addStretch()  # Push everything to top
        
        # Right side - Video display
        video_layout = QVBoxLayout()
        self.image_label = QLabel(alignment=Qt.AlignmentFlag.AlignCenter)
        self.image_label.setMinimumSize(800, 450)
        self.image_label.setStyleSheet("border: 1px solid gray;")
        video_layout.addWidget(self.image_label)
        
        # Add to main layout
        main_layout.addLayout(controls_layout, 1)  # 1/3 width
        main_layout.addLayout(video_layout, 2)     # 2/3 width
        self.setLayout(main_layout)

        # Initialize variables
        self.current_resolution = None
        self.last_frame = None
        self.last_found = False
        self.last_corners = None
        self.objpoints = []
        self.imgpoints = []
        self.frames = []
        self.target_resolution = None # To track what we're waiting for

        # Template for object points, used for all captures
        self.objp_template = np.zeros((CHESSBOARD_SIZE[0] * CHESSBOARD_SIZE[1], 3), np.float32)
        self.objp_template[:, :2] = np.mgrid[0:CHESSBOARD_SIZE[0], 0:CHESSBOARD_SIZE[1]].T.reshape(-1, 2)
        self.objp_template *= SQUARE_SIZE

        bridge.new_frame.connect(self.handle_frame)

        self.frame_timer = QTimer(self)
        self.frame_timer.timeout.connect(self.process_frame_queue)
        self.frame_timer.start(30)
        
        # Update progress on startup
        self.update_progress_display()

        self.calibration_thread = None
        self.calibration_worker = None

    def apply_stream_settings(self):
        """Send resolution, FPS, and JPEG quality change command to server"""
        idx = self.resolution_combo.currentIndex()
        if idx >= 0:
            label, (width, height) = RESOLUTION_LIST[idx]
            self.target_resolution = (width, height)

            # Get values from your UI elements
            jpeg_quality = self.jpeg_quality_spinbox.value() # Assuming you added this
            fps = self.fps_spinbox.value()                   # Assuming you added this

            try:
                config = {
                    "jpeg_quality": jpeg_quality, # Use value from UI
                    "fps": fps,                   # Use value from UI
                    "resolution": (width, height),
                    "cropped": False # Always false for calibration
                }
                sio.emit("camera_config", config)
                self.status_label.setText(f"Applying: {label}, {fps}FPS, Q{jpeg_quality} (waiting)...")
                
                self.set_resolution_btn.setEnabled(False) 
                
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to apply settings: {e}")
                print(f"[ERROR] Stream settings change failed: {e}")
                self.target_resolution = None 
                self.set_resolution_btn.setEnabled(True)

    def handle_frame(self, frame):
        h, w = frame.shape[:2]
        self.current_resolution = (w, h)
        self.current_res_label.setText(f"Current: {w}x{h}")

        # Check if this frame matches the target resolution
        if self.target_resolution and self.current_resolution == self.target_resolution:
            self.status_label.setText(f"âœ“ Resolution set to {w}x{h}")
            self.set_resolution_btn.setEnabled(True)
            self.target_resolution = None # Clear target

        self.last_frame = frame.copy()
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        flags = cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE
        found, corners = cv2.findChessboardCorners(gray, CHESSBOARD_SIZE, flags)

        if found:
            self.last_found = True
            self.last_corners = corners
            self.capture_btn.setEnabled(True)
            cv2.drawChessboardCorners(frame, CHESSBOARD_SIZE, corners, found)
            self.status_label.setText("âœ“ Chessboard detected - Ready to capture")
        else:
            self.last_found = False
            self.last_corners = None
            self.capture_btn.setEnabled(False)
            self.status_label.setText("âŒ No chessboard found")

        # Display frame
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb.shape
        label_w = self.image_label.width()
        label_h = self.image_label.height()

        scale = min(label_w / w, label_h / h)
        new_w, new_h = int(w * scale), int(h * scale)
        resized = cv2.resize(rgb, (new_w, new_h), interpolation=cv2.INTER_AREA)

        qimg = QImage(resized.data, new_w, new_h, new_w * ch, QImage.Format.Format_RGB888)
        pixmap = QPixmap.fromImage(qimg)
        self.image_label.setPixmap(pixmap)

    def capture_frame(self):
        if self.last_frame is not None and self.last_found and self.last_corners is not None:
            self.frames.append(self.last_frame.copy())
            self.objpoints.append(self.objp_template) # Use the template
            self.imgpoints.append(self.last_corners)

            count = len(self.frames)
            self.count_label.setText(f"Captured: {count}")
            self.status_label.setText(f"âœ“ Frame {count} captured")
            
            if count >= 5:
                self.calibrate_btn.setEnabled(True)
                self.status_label.setText(f"âœ“ {count} frames captured - Ready to calibrate")

    def run_calibration(self):
        if len(self.objpoints) < 5:
            QMessageBox.warning(self, "Not Enough Frames", "Capture at least 5 chessboard frames.")
            return

        # Check if a calibration is already running
        if self.calibration_thread is not None and self.calibration_thread.isRunning():
            QMessageBox.information(self, "In Progress", "Calibration is already in progress.")
            return

        self.status_label.setText("ðŸ”„ Running calibration (this may take a moment)...")
        self.set_ui_enabled_for_calibration(False)

        self.calibration_thread = QThread()
        self.calibration_worker = CalibrationWorker(
            list(self.objpoints), list(self.imgpoints), self.frames[0].shape[1::-1]
        )
        self.calibration_worker.moveToThread(self.calibration_thread)

        # Connections
        self.calibration_worker.calibration_finished.connect(self.handle_calibration_results)
        self.calibration_thread.started.connect(self.calibration_worker.run)
        
        # Clean up worker and thread when worker is done and thread finishes
        self.calibration_worker.calibration_finished.connect(self.calibration_worker.deleteLater)
        self.calibration_worker.calibration_finished.connect(self.calibration_thread.quit)
        self.calibration_thread.finished.connect(self.calibration_thread.deleteLater)
        
        # Crucially, nullify references once the thread is truly finished and deleted
        self.calibration_thread.finished.connect(self._on_calibration_thread_finished)

        self.calibration_thread.start()

    def _on_calibration_thread_finished(self):
        """Slot to nullify thread and worker references after thread deletion."""
        print("[DEBUG] Calibration thread finished and cleaned up.")
        self.calibration_thread = None 
        # Worker is deleted via its own calibration_finished -> deleteLater connection
        # but good to nullify the reference if you might check self.calibration_worker elsewhere
        self.calibration_worker = None 
        # Re-enable UI if it wasn't done by handle_calibration_results (e.g., if thread quit unexpectedly)
        # However, handle_calibration_results should always be called.
        if not self.calibrate_btn.isEnabled(): # Check if UI is still disabled
             self.set_ui_enabled_for_calibration(True)


    def handle_calibration_results(self, success, mtx, dist, error_message):
        self.set_ui_enabled_for_calibration(True)

        if success:
            self.calibration = {"mtx": mtx, "dist": dist}
            if self.current_resolution in BASE_CALIBRATION_RESOLUTIONS:
                self.status_label.setText(f"âœ“ Calibration for {self.current_resolution[0]}x{self.current_resolution[1]} successful! Ready to save as base.")
                self.save_btn.setEnabled(True)
            else:
                self.status_label.setText(f"âœ“ Calibrated {self.current_resolution[0]}x{self.current_resolution[1]}. Save disabled (not a base resolution).")
                self.save_btn.setEnabled(False)
                QMessageBox.information(self, "Calibration Note",
                                        f"Calibration for {self.current_resolution[0]}x{self.current_resolution[1]} was successful.\n"
                                        "However, to save this as a base calibration and generate derived files, "
                                        "please capture and calibrate at one of the base resolutions:\n"
                                        f"- {BASE_CALIBRATION_RESOLUTIONS[0][0]}x{BASE_CALIBRATION_RESOLUTIONS[0][1]}\n"
                                        f"- {BASE_CALIBRATION_RESOLUTIONS[1][0]}x{BASE_CALIBRATION_RESOLUTIONS[1][1]}\n"
                                        f"- {BASE_CALIBRATION_RESOLUTIONS[2][0]}x{BASE_CALIBRATION_RESOLUTIONS[2][1]}")
        else:
            self.status_label.setText(f"âŒ Calibration failed: {error_message}")
            QMessageBox.warning(self, "Calibration Failed", f"Calibration failed: {error_message}\nTry capturing more varied frames.")
        
        # Worker and thread are scheduled for deletion by their signal connections.
        # self.set_ui_enabled_for_calibration(True) # Called at the beginning now

    def set_ui_enabled_for_calibration(self, enabled):
        self.capture_btn.setEnabled(enabled and self.last_found)
        self.calibrate_btn.setEnabled(enabled and len(self.frames) >= 5)
        
        # Save button is handled by handle_calibration_results based on whether it's a base resolution
        # self.save_btn.setEnabled(enabled and hasattr(self, 'calibration') and self.current_resolution in BASE_CALIBRATION_RESOLUTIONS)
        
        can_change_stream = enabled and (self.calibration_thread is None or not self.calibration_thread.isRunning())
        self.set_resolution_btn.setEnabled(can_change_stream)
        self.start_stream_btn.setEnabled(can_change_stream)
        self.stop_stream_btn.setEnabled(can_change_stream)
        self.reset_btn.setEnabled(can_change_stream)
        self.resolution_combo.setEnabled(can_change_stream)


    def save_calibration(self):
        if not hasattr(self, "calibration") or not self.current_resolution:
            QMessageBox.warning(self, "No Data", "No calibration data to save.")
            return

        if self.current_resolution not in BASE_CALIBRATION_RESOLUTIONS:
            QMessageBox.warning(self, "Not a Base Resolution",
                                "Calibration data can only be saved if performed at one of the base resolutions:\n"
                                f"- {BASE_CALIBRATION_RESOLUTIONS[0][0]}x{BASE_CALIBRATION_RESOLUTIONS[0][1]}\n"
                                f"- {BASE_CALIBRATION_RESOLUTIONS[1][0]}x{BASE_CALIBRATION_RESOLUTIONS[1][1]}\n"
                                f"- {BASE_CALIBRATION_RESOLUTIONS[2][0]}x{BASE_CALIBRATION_RESOLUTIONS[2][1]}\n"
                                "Please re-capture and calibrate at a base resolution.")
            return

        os.makedirs(CALIBRATIONS_SUBDIR, exist_ok=True)
        
        base_res_tuple = self.current_resolution
        base_filename = RESOLUTION_FILES.get(base_res_tuple)
        
        if not base_filename:
            self.status_label.setText(f"Error: No filename defined for {base_res_tuple}")
            return

        mtx_base = self.calibration["mtx"]
        dist_base = self.calibration["dist"]

        # Save the base calibration file
        np.savez(base_filename, mtx=mtx_base, dist=dist_base)
        self.status_label.setText(f"âœ… Saved base: {base_filename}")
        print(f"[INFO] Saved base calibration: {base_filename}")

        # Generate and save derived calibration files
        if base_res_tuple in DERIVED_MAPPINGS:
            for derived_res_tuple in DERIVED_MAPPINGS[base_res_tuple]:
                derived_filename = RESOLUTION_FILES.get(derived_res_tuple)
                if not derived_filename:
                    print(f"[WARNING] No filename defined for derived resolution {derived_res_tuple}")
                    continue

                scale_w = derived_res_tuple[0] / base_res_tuple[0]
                scale_h = derived_res_tuple[1] / base_res_tuple[1]

                mtx_derived = mtx_base.copy()
                mtx_derived[0, 0] *= scale_w  # fx
                mtx_derived[1, 1] *= scale_h  # fy
                mtx_derived[0, 2] *= scale_w  # cx
                mtx_derived[1, 2] *= scale_h  # cy
                # dist_derived is dist_base (no scaling for distortion coefficients here)

                np.savez(derived_filename, mtx=mtx_derived, dist=dist_base)
                print(f"[INFO] Generated and saved derived calibration: {derived_filename}")
        
        self.update_progress_display()
        
        remaining_base = self.get_remaining_base_calibrations()
        if remaining_base:
            msg = f"Base calibration {base_res_tuple[0]}x{base_res_tuple[1]} and its derived files saved!\n\n"
            msg += f"Remaining base calibrations to perform: {len(remaining_base)}\n"
            msg += "\n".join([f"â€¢ {r[0]}x{r[1]}" for r in remaining_base[:3]]) # Show next few
            if len(remaining_base) > 3:
                msg += f"\n... and {len(remaining_base)-3} more"
            
            reply = QMessageBox.question(self, "Continue?", 
                                       msg + "\n\nContinue with next base resolution?",
                                       QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            
            if reply == QMessageBox.StandardButton.Yes:
                self.reset_calibration() # Reset for next calibration
                # Optionally, auto-select the next base resolution in the dropdown
                if remaining_base:
                    next_base_res_str = f"{remaining_base[0][0]}x{remaining_base[0][1]}"
                    index = self.resolution_combo.findText(next_base_res_str)
                    if index >=0:
                        self.resolution_combo.setCurrentIndex(index)
                        self.status_label.setText(f"Select {next_base_res_str} and apply stream settings.")
        else:
            QMessageBox.information(self, "All Base Calibrations Complete!", "ðŸŽ‰ All base calibrations and their derived files have been generated!")

    def get_remaining_base_calibrations(self):
        """Get list of BASE resolutions that still need direct calibration."""
        remaining = []
        for res_tuple in BASE_CALIBRATION_RESOLUTIONS:
            filename = RESOLUTION_FILES.get(res_tuple)
            if not filename or not os.path.exists(filename):
                remaining.append(res_tuple)
        return remaining

    def update_progress_display(self):
        """Update the progress display showing completed base and derived calibrations."""
        
        progress_lines = []
        total_files_to_generate = len(RESOLUTION_FILES)
        actual_files_generated = 0

        for base_res in BASE_CALIBRATION_RESOLUTIONS:
            base_filename = RESOLUTION_FILES.get(base_res)
            base_exists = base_filename and os.path.exists(base_filename)
            if base_exists:
                actual_files_generated +=1

            progress_lines.append(f"Base {base_res[0]}x{base_res[1]}: {'âœ“ Done' if base_exists else 'âŒ Pending'}")

            if base_res in DERIVED_MAPPINGS:
                for derived_res in DERIVED_MAPPINGS[base_res]:
                    derived_filename = RESOLUTION_FILES.get(derived_res)
                    derived_exists = derived_filename and os.path.exists(derived_filename)
                    if derived_exists:
                         actual_files_generated +=1
                    
                    # Show derived status only if base exists or if we want to show all pending
                    if base_exists: # Only show derived status if base is done
                        progress_lines.append(f"  â”” Derived {derived_res[0]}x{derived_res[1]}: {'âœ“ Generated' if derived_exists else 'â³ Missing (base done)'}")
                    elif derived_filename: # If base not done, just show derived as pending
                         progress_lines.append(f"  â”” Derived {derived_res[0]}x{derived_res[1]}: {'âŒ Pending'}")


        # Check for any other files in RESOLUTION_FILES not covered by base/derived (should not happen with current setup)
        all_listed_files = set(RESOLUTION_FILES.values())
        covered_files = set()
        for br in BASE_CALIBRATION_RESOLUTIONS:
            bf = RESOLUTION_FILES.get(br)
            if bf: covered_files.add(bf)
            if br in DERIVED_MAPPINGS:
                for dr in DERIVED_MAPPINGS[br]:
                    df = RESOLUTION_FILES.get(dr)
                    if df: covered_files.add(df)
        
        # Recalculate actual_files_generated by checking all files in RESOLUTION_FILES
        actual_files_generated = sum(1 for f in RESOLUTION_FILES.values() if os.path.exists(f))


        self.progress_label.setText(
            f"Calibration File Status ({actual_files_generated}/{total_files_to_generate} total files):\n" + 
            "\n".join(progress_lines)
        )

    def closeEvent(self, event):
        if self.calibration_thread is not None and self.calibration_thread.isRunning():
            print("[INFO] Quitting calibration thread on close...")
            self.calibration_worker.calibration_finished.disconnect(self.handle_calibration_results) # Avoid double handling
            self.calibration_worker.calibration_finished.disconnect(self.calibration_worker.deleteLater)
            self.calibration_worker.calibration_finished.disconnect(self.calibration_thread.quit)
            self.calibration_thread.finished.disconnect(self.calibration_thread.deleteLater)
            self.calibration_thread.finished.disconnect(self._on_calibration_thread_finished)
            
            self.calibration_thread.quit()
            if not self.calibration_thread.wait(2000): # Wait up to 2 seconds
                print("[WARNING] Calibration thread did not finish gracefully on close.")
            # else:
            # print("[INFO] Calibration thread finished on close.")
        
        # Nullify to prevent issues if closeEvent is somehow called again or app doesn't exit immediately
        self.calibration_thread = None
        self.calibration_worker = None

        try:
            if sio.connected:
                sio.emit("stop_camera")  # Stop camera before disconnecting
                sio.disconnect()
        except:
            pass
        event.accept()

    def process_frame_queue(self):
        try:
            frame = frame_queue.get_nowait()
            self.handle_frame(frame)
        except queue.Empty:
            pass

    def reset_calibration(self):
        """Resets the calibration state to start fresh."""
        if self.calibration_thread is not None and self.calibration_thread.isRunning():
            QMessageBox.warning(self, "Calibration in Progress", 
                                "Cannot reset while calibration is running. Please wait.")
            return

        self.objpoints = []
        self.imgpoints = []
        self.frames = []
        if hasattr(self, 'calibration'):
            del self.calibration # Remove previous calibration results
        
        self.count_label.setText("Captured: 0")
        self.status_label.setText("Status: Ready for new calibration.")
        self.capture_btn.setEnabled(False) # Disabled until a board is found
        self.calibrate_btn.setEnabled(False)
        self.save_btn.setEnabled(False)
        
        # Optionally, you might want to reset the selected resolution or prompt the user
        # For now, it just clears the data for the current/next selected resolution.
        print("[INFO] Calibration state reset.")
        # Ensure UI is correctly enabled after reset
        self.set_ui_enabled_for_calibration(True) 
        self.capture_btn.setEnabled(self.last_found) # Re-check capture button based on current board state
        self.calibrate_btn.setEnabled(False) # No frames yet
        self.save_btn.setEnabled(False) # No calibration yet

    def confirm_clear_all_calibrations(self):
        reply = QMessageBox.warning(self, "Confirm Clear All",
                                    "This will delete ALL saved .npz calibration files in the 'calibrations' directory "
                                    "associated with the predefined resolutions.\n"
                                    "Are you sure you want to proceed?",
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                    QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            self.do_clear_all_calibrations()

    def do_clear_all_calibrations(self):
        cleared_count = 0
        failed_count = 0
        os.makedirs(CALIBRATIONS_SUBDIR, exist_ok=True) # Ensure directory exists

        # Iterate through all defined resolution files
        for res_tuple, filepath in RESOLUTION_FILES.items():
            try:
                if os.path.exists(filepath):
                    os.remove(filepath)
                    print(f"[INFO] Deleted: {filepath}")
                    cleared_count += 1
            except Exception as e:
                print(f"[ERROR] Failed to delete {filepath}: {e}")
                failed_count += 1
        
        self.update_progress_display() # Refresh progress
        if failed_count > 0:
            QMessageBox.warning(self, "Clear Incomplete", f"Successfully deleted {cleared_count} files.\nFailed to delete {failed_count} files. Check console for errors.")
        else:
            QMessageBox.information(self, "Clear Complete", f"Successfully deleted {cleared_count} calibration files.")
        self.status_label.setText("All saved calibrations cleared. Ready to start fresh.")


# === SocketIO Events ===

@sio.on("frame")
def on_frame(data):
    try:
        arr = np.frombuffer(data, np.uint8)
        frame = cv2.imdecode(arr, cv2.IMREAD_COLOR)
        if frame is not None:
            try:
                frame_queue.put_nowait(frame)
            except queue.Full:
                pass
    except Exception as e:
        print(f"[ERROR] Frame decode failed: {e}")

# Add this SocketIO event to automatically start the camera when connected
@sio.on("connect")
def on_connect():
    print("[DEBUG] Connected to server - starting camera stream")
    if win: # Check if GUI window exists
        win.connection_status_label.setText("Socket.IO: Connected")
        win.status_label.setText("Connected. Starting stream...")
    sio.emit("start_camera")

# Add disconnect cleanup to stop camera
@sio.on("disconnect")
def on_disconnect():
    print("[DEBUG] Disconnected from server")
    if win: # Check if GUI window exists
        win.connection_status_label.setText("Socket.IO: Disconnected")
        win.status_label.setText("Disconnected from server.")
        win.capture_btn.setEnabled(False) # Disable capture if disconnected

# === SocketIO Connection Thread ===

def socket_thread():
    while True:
        try:
            if win: win.connection_status_label.setText("Socket.IO: Connecting...")
            sio.connect(SERVER_URL, wait_timeout=5)
            sio.wait() # This blocks until disconnect
        except socketio.exceptions.ConnectionError as e:
            print(f"[SocketIO Connection ERROR] {e}")
            if win: win.connection_status_label.setText(f"Socket.IO: Connection Failed")
        except Exception as e: # Catch other potential errors during connect/wait
            print(f"[SocketIO ERROR] {e}")
            if win: win.connection_status_label.setText(f"Socket.IO: Error")
        
        if sio.connected: # Should not happen if sio.wait() is used correctly, but as a fallback
            sio.disconnect()

        if win: # Update status before sleep
             if not sio.connected: # Check again before setting disconnected status
                win.connection_status_label.setText("Socket.IO: Disconnected (retrying...)")
        time.sleep(5)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = CalibrationApp() # Ensure 'win' is accessible globally for sio handlers
    win.show()

    threading.Thread(target=socket_thread, daemon=True).start()
    sys.exit(app.exec())
